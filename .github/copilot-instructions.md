---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## <headers/>

## PROJECT RULES

*   The bot must be Ukrainian-language oriented.
*   The bot must be modular.
*   The bot must remember context for the entire duration of the chat.
*   The bot must interact with users in a group chat, responding to their messages and remembering the context.
*   The bot must have a function for random responses to messages when its name, tag, or related words are mentioned, to give it "its own life". These random responses should be generated by Gemini for maximum "liveliness".
*   The bot's persona should be friendly and adequate with natural communication style. The bot should be a helpful and pleasant chat-bot with light humor when appropriate, avoiding excessive absurdity or strange behavior.
*   The bot must use context and dynamically change its persona based on the environment in the chat.
*   The bot should have an anti-spam system with a limit on hourly replies, a minimum pause between spontaneous messages, and a smart reply chance on regular messages.
*   The bot should scan and add the chat history to the database when it first joins a chat.
*   The bot should automatically initialize chats when added to a new one, marking it as ready for operation.
*   The bot should send spontaneous messages from time to time, not in response to anything. These messages should start with 'üí≠'.
*   The bot should implement aggressive throttling, ignoring messages or responding with phrases like "—Ç—ñ—Ö–∞ –±–ª—è—Ç—å, —Ö–æ—Ö–ª–∏" when spammed. The bot should track the number of messages a user sends per minute and implement a timeout if a threshold is reached.
*   The bot should ignore old messages received while offline to prevent spamming upon restart.
*   The bot should intelligently react to complex contexts in group chats.
*   The bot's communication should be natural, understandable, and helpful. Avoid using strange words or bizarre expressions.
*   The bot should use minimal safety settings for more free communication.
*   The bot's level of schizoid behavior should be reduced to maintain normal conversation flow.

## CODING STANDARDS

*   Use the latest versions of all libraries and frameworks.
*   Create a `.env` sample file for easy modification of variables.
*   The project structure should be modular, with separate modules for message processing, context storage, Gemini integration, and management.
*   All responses should be in Ukrainian.
*   All responses generated by the bot (not just random ones) must pass through Gemini with a friendly and humorous instruction.
*   Use try/catch blocks in all critical sections for error handling.
*   Use a single universal handler in `main.py` to prevent conflicts.
*   `.env` should be added to `.gitignore` to prevent committing secrets.
*   Add type hints to all functions for improved code quality.
*   When installing Python packages, use a virtual environment to avoid conflicts with system-level packages. Create a virtual environment with `python3 -m venv myenv` and activate it with `source myenv/bin/activate`.
*   Add configurations for `black`, `flake8`, `mypy` in the project root.
*   Configure pre-commit-hooks.

## WORKFLOW & RELEASE RULES

*   Add `.env` to `.gitignore` to prevent committing secrets.
*   Create a startup script (`start.py`) to verify dependencies.
*   The entire bot should be containerized for easy deployment.
*   Record version updates in CHANGELOG.
*   Implement unit-tests for key modules (`enhanced_behavior.py`, `gemini.py`, `rate_limiter.py`, `health_checker.py`, `backup_manager.py`).
*   Add automatic backup on bot start and via `/backup` command.
*   Add logging for backup processes.
*   Add integration test for backup/restore functionality.
*   Add configuration validation on startup.
*   Add test for health checker.
*   Integrate key tests and backup into CI/CD pipeline.
*   Periodically clean up old backups to save space.
*   Create `.github/workflows/ci.yml` with pytest + flake8 + mypy.
*   In `docker-compose.yml`, specify `logging.driver: "json-file"` and resource limits.
*   Set up automatic deployment with checks and backups (call `/backup` in CI).

## TECH STACK

*   Telegram bot library: aiogram.
*   Natural language and image/audio processing backend: Gemini (prioritize free Flash 2.5 if possible). Consider using the latest Claude Sonnet 4 model from Anthropic.
*   Database: SQLite (for storing chat context).
*   Dependencies: python-dotenv, google-generativeai, aiohttp, psutil, pytest, sentence-transformers, spacy.

## PROJECT DOCUMENTATION & CONTEXT SYSTEM

*   Chat context (history) should be stored in a database (SQLite). JSON file storage is less efficient for large context.
*   Implement a function to import chat history from a Telegram JSON file into the bot's database, accessible only to the admin via the command `/import_history <path_to_json> <chat_id>`. The bot can import chat history from a Telegram Desktop `result.json` file via the `/import_history <path_to_json> <chat_id>` command. The bot will scan the file, add messages to the SQLite database (`data/context.db`), and update the context for the chat. This command is only available to admins.
*   The bot should automatically store information about stickers, photos, and audio sent by each user, summarizing them with text to save space. If a sticker/photo/audio with the same ID is repeated, reuse the same description for context. Fast, absurd prefixes should be used for media descriptions instead of Gemini.
*   The database of messages should be compressed over time to fit within the model's context window. Context should be dynamically compressed before sending to the model, potentially by taking the last N thousand characters/messages.
*   Create a separate config file (e.g., `bot_config.py`) for the bot's personality, limits, timings, and admin ID. These values should be loaded from the `.env` file.
*   `BOT_CONTEXT_LIMIT` in the `.env` file defines the number of recent messages used to form the context for Gemini responses. While it can be increased, it's crucial to monitor the total context size to avoid exceeding Gemini's limits (ideally, stay within 10-30k characters for Flash 2.5). The bot should automatically compress the context if the limit is exceeded. This variable specifies the number of recent messages used to form the context. Recommended values: 50-200 for regular chats. Experiment for larger chats but monitor the total size.
*   A `media_map.py` module should be used to store unique descriptions of stickers, photos, and audio, reusing summaries for repeated media. The module should support voice and video, and use faster, non-Gemini generated prefixes for media descriptions.
*   The bot's name is now "–ì—Ä—è–≥" and its tag is "@gryag_bot". These, along with other variations (–≥—Ä—è–≥—ñ–∫, –≥—Ä—è–≥—É, –≥—Ä—è–≥–∞, –≥—Ä—è–≥–æ–º, –±–æ—Ç, –±–æ—Ç–µ), should be used as triggers for random responses. The `TRIGGERS` list in the `random_life.py` module can be updated to add more variations.
*   Each message in the context should have a "mood" tag (e.g. "joke", "fight", "meme", "silence"), potentially determined by Gemini, and a short summary of the "environment" in the chat should be included when forming the prompt for Gemini.
*   Add a `/clear_context` command.
*   Add a `/help` command.
*   Add a `/rescan` command, to force a rescan of the chat. This should be used if the bot was initially added without access to messages. This should be used if the bot was initially added without access to messages.
*   Add `random_reply_chance` and `max_context_size` parameters to `bot_config.py`.
*   The bot should use a smart reply chance, a minimum silence period, and a maximum number of replies per hour to prevent spamming. These values should be configurable via environment variables: `BOT_SMART_REPLY_CHANCE`, `BOT_MIN_SILENCE_MINUTES`, `BOT_MAX_REPLIES_PER_HOUR`, `BOT_AUTONOMOUS_MODE`, and `BOT_SPONTANEOUS_CHANCE`.
*   The bot should automatically initialize chats when added to a new one, marking it as ready for operation.
*   The bot should track scanned chats in `chat_states.json`.
*   The bot can import `chat.json` from Telegram Desktop via the `/import_history` command.
*   Implement a `/stats` command to show the number of messages and active chats.
*   The database, media map and chat states should be stored in the `data/` folder.
*   The bot should use environment variable `GEMINI_MODEL` to select a Gemini model. Default is `Gemini 2.5 Flash`.
*   Implement monitoring of API usage.
*   The bot should implement aggressive anti-spam throttling with configurable parameters: `BOT_SPAM_THRESHOLD`, `BOT_SPAM_TIMEOUT`, and `BOT_SPAM_REPLIES`.
*   The bot should send spontaneous messages from time to time. A background task should check every 5 minutes whether spontaneous activity is needed. Different prompts should be used depending on the mood of the chat (e.g., funny, sad, silence). The chance of a spontaneous message increases after a long silence (1-2 hours). Spontaneous messages should start with 'üí≠'.
*   Implement aggressive anti-spam throttling: track the number of messages a user sends per minute; if spamming (5+ messages per minute), set a timeout of 5 minutes; occasionally reply with phrases like "—Ç—ñ—Ö–∞ –±–ª—è—Ç—å, —Ö–æ—Ö–ª–∏", "–Ω–µ —Å–ø–∞–º—Ç–µ", "–∑–∞—Ç–∫–Ω—ñ—Ç—å—Å—è –Ω–∞ —Ö–≤–∏–ª–∏–Ω–∫—É" (30% chance), otherwise ignore.
*   The bot should use `BOT_SPONTANEOUS_CHANCE` and `BOT_SPONTANEOUS_MIN_PAUSE` variables in `.env` file to control spontaneous messages.
*   The bot should use `BOT_SPAM_THRESHOLD`, `BOT_SPAM_TIMEOUT`, and `BOT_SPAM_REPLIES` variables in `.env` file to control aggressive anti-spam throttling.
*   The bot should ignore old messages received while offline to prevent spamming upon restart. A message is considered old if its timestamp is older than `BOT_START_TIME`. The `BOT_IGNORE_OLD_MESSAGES` variable in `.env` file controls this.
*   Set `BOT_IGNORE_OLD_MESSAGES` to `true` to enable ignoring old messages. The `BOT_MAX_MESSAGE_AGE_MINUTES` variable in `.env` file defines the maximum age of messages to be processed (in minutes).
*   Implement a module for analyzing and predicting chat situations to improve context understanding.
*   Add an admin command `/analytics` to view chat analytics.
*   Update the `/help` command to include the new `/analytics` command.
*   The bot should be able to recognize at least 6 types of conversations: technical, philosophical, funny, emotional, everyday, and conflicts.
*   The bot should use a corresponding tone for each conversation type (e.g., "smart absurd" to "deep absurd"). The bot should now use tones like "smart joke", "friendly joke", or "funny joke" instead.
*   The system should analyze the level of engagement (1-10) and recommend whether to respond.
*   The system should track moods and chat topics over the past few hours for better context understanding.
*   The bot should have an improved system for predicting and understanding context in chats, enabling it to react intelligently.
*   The bot should use a new module for analyzing and predicting situations in the chat.
*   The bot should implement a system that detects conversation types and adjusts its tone accordingly (e.g., "smart absurd" to "deep absurd"). The bot should now use tones like "smart joke", "friendly joke", or "funny joke" instead.
*   The bot should analyze the level of engagement (1-10) and recommend whether to respond.
*   The bot should track moods and chat topics over the past few hours for better context understanding.
*   The bot should use an improved function to detect conversation type, better working with context.
*   **Adjusting Absurdity:** The bot's level of absurdity can be adjusted by modifying the `situation_predictor.py`, `enhanced_behavior.py`, and spontaneous message configurations. Reduce `random_reply_chance` and update default configuration values to decrease absurdity.
*   The bot's random reply chance should be reduced from 50% to 30%.
*   The bot's smart reply chance should be reduced from 10% to 5%.
*   The bot's spontaneous message chance should be reduced from 2% to 1%.
*   The maximum number of replies per hour should be reduced from 3 to 2.
*   The minimum pause between messages should be increased from 15 to 20 minutes.
*   Spontaneous prompts should be "interesting" instead of "absurd".
*   Create `AGENTS.md` to document agent usage and recommendations.
*   Implement a backup manager module (`backup_manager.py`) for database backups.
*   Add a `/health` command in `management.py` to check the bot's status.
*   Implement a `safe_api_call()` function with exponential backoff in `gemini.py` for improved error handling.
*   Implement a `cleanup_old_analysis_data()` function in `enhanced_behavior.py` for memory management.
*   Create `PROJECT_ANALYSIS.md` for detailed project analysis reports.
*   Add the ability to add reactions.
    *   The bot should add automatic reactions to messages depending on context.
    *   The bot should have a 70% chance of reacting on mentions, 30% on questions, and 5% on regular messages.
    *   The bot should use 30+ emojis including üëç‚ù§Ô∏èüî•ü•∞üëèüòÅü§îü§Øüôèüëåüïäü§°üåöüå≠‚ö°Ô∏èüçå.
    *   The bot should use positive reactions on pleasant words, neutral/absurd reactions on regular messages, and thoughtful reactions on questions.
*   The bot should implement smart message processing in `enhanced_behavior.py`, especially when spam is detected in the chat, to prevent spam and nonsense from the bot. This includes adjusting response strategies and context handling.
*   The bot's level of schizoid behavior should be reduced.
*   The bot's standard security settings should be lowered to the minimum level.
*   Consider integrating a local language model for analyzing conversations, summarizing elements, and then passing relevant information to Gemini.
*   A comprehensive codebase review should be conducted to identify potential areas for improvement or issues.
*   **Gemini API Message Format:** The bot uses JSON format to send messages to the Gemini API. See details in [Gemini API Message Format](#gemini-api-message-format).

## DEBUGGING

*   Ensure random responses are handled asynchronously using `await`.
*   Improve error handling by implementing rate limiting and safe message sending to avoid flood control errors from Telegram.
*   The context insertion into messages should be fixed to improve readability and correctness.
*   Address static type checking errors for improved code quality, even if they don't cause runtime issues.
*   Add a check for `None` to handle cases where `message.from_user.full_name` might be empty.
*   The bot's personality has been corrected to be less schizoid - system instructions, tone mappings, and spontaneous prompts have been updated to be more natural and friendly.
*   Safety settings have been lowered to minimum levels (BLOCK_NONE for most categories) to enable more free communication.
*   Log the response time of API calls in `gemini.py` (using `safe_api_call()` with exponential backoff).

## REFERENCES

*   [GitHub Copilot serves Claude Sonnet 4](https://docs.github.com/en/copilot/using-github-copilot/ai-models/using-claude-sonnet-in-github-copilot).

## BEST PRACTICES

*   All admin commands should be processed through a single, absurd Gemini prompt, while maintaining a degree of friendliness.
*   Add type hints to all functions.
*   Add docstrings to tests.
*   Update `README.md` with examples of running in Docker (`docker-compose.yml`).
*   Add examples of requests to `/analytics`, `/stats`, `/backup` in `AGENTS.md`.

## GEMINI API FREE LIMITS (June 2025)

### üíé **Free Models:**
*   **Gemini 2.5 Flash** (Recommended for bots)
*   **Gemini 2.0 Flash**
*   **Gemini 1.5 Flash/Pro**
*   **Text Embedding 004**
*   **Gemini 2.5 Pro** (Paid only)

### üìä **Free Tier Limits:**
*   **RPM** (Requests Per Minute): ~15-60 requests/min
*   **TPM** (Tokens Per Minute): Limited
*   **RPD** (Requests Per Day): Daily quotas
*   **Context Window**: Up to 1M tokens
*   **Data Usage**: Google uses data for product improvement

### üéØ **Optimizations for –ì—Ä—è–≥-bot:**
*   Anti-spam system with reply limits
*   Local context cache in SQLite
*   Absurd prefixes for media (token saving)
*   Configurable model via `.env`

### üöÄ **Recommendation:**
Use **Gemini 2.5 Flash** - best balance of quality, speed, and cost for chat bots.

## DOCKER DEPLOYMENT

*   To connect to the bot's logs in a Docker container, use the following commands:

    ### üìã **Basic Commands for Logs**

    ````bash
    # View current container logs
    docker logs pomiyka-bot

    # Follow logs in real time
    docker logs -f pomiyka-bot

    # Show the last N lines of logs
    docker logs --tail 50 pomiyka-bot

    # Logs with timestamps
    docker logs -t pomiyka-bot

    # Logs for a specific period
    docker logs --since "2h" pomiyka-bot
    docker logs --until "2023-12-01T12:00:00" pomiyka-bot
    ````

    ### üîç **Find Container Name**

    ````bash
    # List all running containers
    docker ps

    # List all containers (including stopped ones)
    docker ps -a

    # Search for a container by name
    docker ps | grep bot
    ````

    ### üìù **Additional Logging Options**

    ````bash
    # Combination of options (last 100 lines with real time and labels)
    docker logs -f --tail 100 -t pomiyka-bot

    # Export logs to a file
    docker logs pomiyka-bot > bot_logs.txt 2>&1

    # Filtering logs through grep
    docker logs pomiyka-bot 2>&1 | grep "ERROR"
    docker logs pomiyka-bot 2>&1 | grep "–ì—Ä—è–≥"
    ````

    ### ‚öôÔ∏è **Configuring Logging in Docker Compose**

    If you are using `docker-compose.yml`, add a logging section:

    ````yaml
    services:
      pomiyka-bot:
        # ...existing code...
        logging:
          driver: "json-file"
          options:
            max-size: "10m"
            max-file: "3"
        # ...existing code...
    ````

    ### üõ†Ô∏è **Interactive Access to the Container**

    ````bash
    # Connect to the running container
    docker exec -it pomiyka-bot /bin/bash

    # Or if bash is not available
    docker exec -it pomiyka-bot /bin/sh

    # View log files inside the container
    docker exec -it pomiyka-bot ls -la /app/logs/
    ````

    ### üìä **Resource Monitoring**

    ````bash
    # Statistics of resource usage
    docker stats pomiyka-bot

    # Container information
    docker inspect pomiyka-bot
    ````

## SYSTEM IMPROVEMENTS PLAN

*   The following is a plan for system improvements:

    1.  **Testing Coverage**
        *   Add unit tests for the following modules:
            *   `backup_manager.py`
            *   `health_checker.py`
            *   `rate_limiter.py`
            *   `media_map.py`
        *   Add integration tests for the universal handler in `main.py` and `/analytics`.

    2.  **Database Optimization**
        *   Index fields in `data/context.db`:
            ```sql
            CREATE INDEX idx_messages_chat ON messages(chat_id);
            CREATE INDEX idx_messages_time ON messages(timestamp);
            ```
        *   Switch to `aiosqlite` in `bot/modules/context_sqlite.py` to avoid blocking.

    3.  **Linting and Formatting**
        *   Add configurations for `black`, `flake8`, `mypy` in the project root.
        *   Configure pre-commit-hooks.

    4.  **Monitoring and Metrics**
        *   Expand `health_checker.py`: add CPU/memory usage from `psutil`.
        *   Log API call response times in `gemini.py` (use `safe_api_call()` with exponential backoff).

    5.  **Documentation**
        *   Update `README.md` with examples of running in Docker (`docker-compose.yml`).
        *   Add `.env.sample` (see Coding Standards).
        *   Add examples of requests to `/analytics`, `/stats`, `/backup` in `AGENTS.md`.

    6.  **Context Management**
        *   In `bot/modules/enhanced_behavior.py`, add a background task for `cleanup_old_analysis_data()`.
        *   Review context compression parameters (monitor by token size).

    7.  **Scalability Expansion**
        *   Abstract the context storage interface (to allow switching to PostgreSQL).
        *   Consider a local LLM for pre-processing before sending to Gemini.

    8.  **Security and Configuration**
        *   Add validation for all critical variables in `bot_config.py` (TELEGRAM_BOT_TOKEN, GEMINI_API_KEY, etc.).
        *   Ensure `.env` is always in `.gitignore`.

    9.  **Docker & CI/CD**
        *   In `docker-compose.yml`, specify `logging.driver: "json-file"` and resource limits.
        *   Set up automatic deployment with checks and backups (call `/backup` in CI).

    10. **Future Plan**
        *   Consider a web dashboard with statistics (REST API).
        *   Support multi-language (based on modular architecture).

## GEMINI API MESSAGE FORMAT

Messages to the Gemini API (e.g., for the Gemini 2.5 Flash model) are sent in JSON format via an HTTP POST request. The format depends on the specific library, but the basic structure is as follows:

### 1. Endpoint
```
POST https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key=YOUR_API_KEY
```

### 2. Headers
```json
Content-Type: application/json
```

### 3. Request Body
The body contains an array of "contents", where each element is a message from the user or assistant. For example:

````json
{
  "contents": [
    {
      "role": "user",
      "parts": [
        { "text": "–ü—Ä–∏–≤—ñ—Ç, —è–∫ —Å–ø—Ä–∞–≤–∏?" }
      ]
    }
  ],
  "generationConfig": {
    "temperature": 0.7,
    "topP": 0.95,
    "maxOutputTokens": 1024
  }
}
````

#### Key Fields:
- **contents** ‚Äî array of messages (chat history). Each element:
    - **role**: "user" or "model" (sometimes "assistant").
    - **parts**: array of message parts (e.g., text, images, audio).
        - For text: `{ "text": "..." }`
        - For images: `{ "inlineData": { "mimeType": "...", "data": "..." } }`
- **generationConfig** ‚Äî additional generation parameters (optional).

### 4. Example for a Multi-Message Chat:
````json
{
  "contents": [
    {
      "role": "user",
      "parts": [{ "text": "–ü—Ä–∏–≤—ñ—Ç, —è–∫ —Ç–µ–±–µ –∑–≤–∞—Ç–∏?" }]
    },
    {
      "role": "model",
      "parts": [{ "text": "–Ø ‚Äî –ì—Ä—è–≥, —Ç–≤—ñ–π –±–æ—Ç-–ø–æ–º—ñ—á–Ω–∏–∫!" }]
    },
    {
      "role": "user",
      "parts": [{ "text": "–†–æ–∑–∫–∞–∂–∏ –∞–Ω–µ–∫–¥–æ—Ç." }]
    }
  ]
}
````

### 5. API Response
The API returns JSON with a `candidates` field, which contains the model's response.